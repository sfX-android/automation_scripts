---

- name: "Push any detected change"
  shell: |
    export LC_ALL=C
    {{ DOS_INIT }}

    # tag name
    TAG=$(date +%F)"_${BDEVICE}_{{ android_shortversion }}"
    
    # reproduce manifest
    REPRMANIFEST=".repo/local_manifests/axp_cicd.xml.repr"

    # write full manifest
    {{ repo_bin }} manifest -r -o ${REPRMANIFEST}
    
    
    # starting new reproduce manifest
    #echo -e '<?xml version="1.0" encoding="UTF-8"?>\n<manifest>\n\t<!-- auto-created by https://github.com/sfX-android/automation_scripts/blob/ansible/roles/axp/common/tasks/git_push.yml -->\n' > ${REPRMANIFEST}
    
    # check where we changed origin
    for repo in $({{ repo_bin }} list | tr -d ' ');do
      croot
      reponame_orig=$(echo "$repo" | cut -d ':' -f2)
      reponame=$(echo "$repo" | cut -d ':' -f2 | sed 's#LineageOS/##g;s#/#_#g')
      localpath=$(echo "$repo" | cut -d ':' -f1)

      cd $localpath

      # commit any leftovers!
      # besides "normal" patches divest also run several patch scripts(!) which by design can not be
      # catched regularly (i.e. they do not use git am, git apply, patch .. but awk, sed etc to modify)
      # to also make these changes available for reproducible builds and transparency we commit them once now:
      CMT=0
      # add unstaged changes
      git add -A >> {{ BUILD_LOG }} 2>&1 || CMT=1
      # check for uncommitted changes
      CMTL=$(git status --porcelain=v1 | wc -l 2>/dev/null)
      # commit if any of the above require it
      if [ $CMT -eq 1 -o $CMTL -gt 0 ];then 
          git commit --author="${DOS_GIT_AUTHOR} <${DOS_GIT_MAIL}>" -m "uncatched DOS scripted change(s)"
          echo "[GIT] committed scripted divest changes for $reponame" >> {{ BUILD_LOG }}
      fi

      # check and add new repo if needed only
      CURHASH=$(git log -1 --format=oneline | cut -d ' ' -f1)
      REMHASH=$({{ repo_bin }} info . | grep -i "Current revision" | tr -d ' ' | cut -d ':' -f2)
      
      if [ "$CURHASH" != "$REMHASH" ]; then
        echo -e "\n[GIT] WARNING: changes detected in $localpath ($reponame) which needs to be pushed!\n" >> {{ BUILD_LOG }}
      else
        echo "[GIT] no changes in $localpath, skipping" >> {{ BUILD_LOG }}
        continue
      fi
      
      # create repo if non-existent
      # using a workaround as github cli does not allow to set permission on create
      # see: https://github.com/cli/cli/issues/2241#issuecomment-1402316546
      # requires to auth via gh first: $> gh auth login
      git remote remove up 2>> /dev/null || true
      git remote add up git@github.com:AXP-OS/${reponame}.git
      
      if $(git fetch up >> /dev/null 2>&1);then
        echo "[GIT] repo exists within the org already" >> {{ BUILD_LOG }}
      else
        echo "[GIT] repo does not exist within the org yet! Creating..." >> {{ BUILD_LOG }}
        git remote remove up 2>> /dev/null || true
        gh repo create AXP-OS/${reponame} --public --source=. --remote=up --disable-issues --disable-wiki --team bots --description "forked from: $(git remote -v | head -n1 | cut -f2 | cut -d ' ' -f1)"
        gh api -X PUT "/orgs/AXP-OS/teams/bots/repos/AXP-OS/${reponame}" -f 'permission=maintain'
      fi
      
      # push origin sources first
      # falls back to push in batches to workaround issues when index pack is too big
      rerr=0
      git push --force -u up $REMHASH:refs/heads/upstream_{{ android_shortversion }} >> /dev/null 2>> {{ BUILD_LOG }} || rerr=$?
      if [ $rerr -ne 0 ]; then
          resp=$(git push --force -u up $REMHASH:refs/heads/upstream_{{ android_shortversion }} >> /dev/null 2>&1 || true)
          found=0
          echo "$resp" | tail -n 20 | grep -q "pack exceeds maximum allowed size" || found=1
          if [ $found -eq 0 ]; then
              echo "[GIT] pack size too big for $reponame, pushing in chunks now.." >> {{ BUILD_LOG }}
              max=$(git log --oneline|wc -l); for i in $(seq  $max -60000 1); do echo $i; g=$(git log --reverse --oneline --skip $i -n1|perl -alne'print $F[0]'); git push --force up $g:refs/heads/upstream_{{ android_shortversion }} >> {{ BUILD_LOG }} 2>&1; done \
              || (echo "[GIT] reducing chunk size to: 10000" >> {{ BUILD_LOG }} ; max=$(git log --oneline|wc -l); for i in $(seq  $max -10000 1); do echo $i; g=$(git log --reverse --oneline --skip $i -n1|perl -alne'print $F[0]'); git push --force up $g:refs/heads/upstream_{{ android_shortversion }} >> {{ BUILD_LOG }} 2>&1; done) \
              || (echo "[GIT] reducing chunk size even more to: 1000"  >> {{ BUILD_LOG }}; max=$(git log --oneline|wc -l); for i in $(seq  $max -1000 1); do echo $i; g=$(git log --reverse --oneline --skip $i -n1|perl -alne'print $F[0]'); git push --force up $g:refs/heads/upstream_{{ android_shortversion }} >> {{ BUILD_LOG }} 2>&1; done)
              if [ $? -ne 0 ];then
                  echo "$resp" | tail -n 20 >> {{ BUILD_LOG }}
                  exit 3
              fi
              # now the final push should just work
              git push --force -u up $REMHASH:refs/heads/upstream_{{ android_shortversion }}
          else
             found=0
             echo "$resp" | tail -n 20 | grep -q "fatal: did not receive expected object" || found=1
             if [ $found -eq 0 ]; then
               obj=$(echo "$resp" | tail -n 20 | grep -o "fatal: did not receive expected object .*" | cut -d ' ' -f 7)
               git push --force -u up ${obj}:refs/heads/upstream_{{ android_shortversion }} >> {{ BUILD_LOG }} 2>&1
               git push --force -u up $REMHASH:refs/heads/upstream_{{ android_shortversion }} >> {{ BUILD_LOG }} 2>&1
             else
               echo "[GIT] error $rerr occured while pushing" >> {{ BUILD_LOG }}
               echo "$resp" | tail -n 20 >> {{ BUILD_LOG }}
               exit $rerr
             fi
          fi
      fi
      echo "[GIT] pushed/updated upstream_{{ android_shortversion }}" >> {{ BUILD_LOG }}

      # tag the current patched state and push accordingly
      git tag -a "$TAG" -m "axp.os: tagged on $TAG" 2>> /dev/null || (git tag -d "$TAG"; git push up --delete "$TAG" 2>> /dev/null || true; git tag -a "$TAG" -m "axp.os: tagged on $TAG")
      #git tag latest 2>> /dev/null || (git tag -d latest; git push up --delete latest 2>> /dev/null || true; git tag latest)      
      git push --set-upstream up $TAG
      echo "[GIT] pushed/updated tag: $TAG" >> {{ BUILD_LOG }}

      # change manifest line to point to AXP.OS org
      croot
      #echo -e '\n\t<remove-project name="'$reponame_orig'" />' >> ${REPRMANIFEST}
      #echo -e '\t<project path="'$localpath'" name="'$reponame'" remote="axp.os" revision="refs/tags/'$TAG'" />' >> ${REPRMANIFEST}
      sed -i -E 's|(name=".*") (path="'$localpath'")|name="'$reponame'" \2 remote="axp.os" |g' ${REPRMANIFEST}
      echo "[GIT] updated manifest for: $reponame" >> {{ BUILD_LOG }}
    done
    
    # closing new manifest
    croot
    #echo -e '\n</manifest>' >> ${REPRMANIFEST}

    # push manifest
    mv ${REPRMANIFEST} .repo/local_manifests/axp.xml
    cd .repo/local_manifests/
    cp -a {{ BUILDHOME }}/build_{{ target_model }}_{{ android_shortversion }}_{{ ROM_FLAVOR }}.sh . || true
    git remote remove up 2>> /dev/null || true
    git remote add up git@github.com:AXP-OS/manifest.git
    git add -A || true
    git commit --author="${AXP_GIT_AUTHOR} <${AXP_GIT_MAIL}>" -m "added/changed $TAG"
    git tag -a "$TAG" -m "axp.os: tagged on $TAG" 2>> /dev/null || (git tag -d "$TAG"; git push up --delete "$TAG" 2>> /dev/null || true ; git tag -a "$TAG" -m "axp.os: tagged on $TAG")
    git push --set-upstream up $TAG
    echo "[GIT] pushed manifest tag: $TAG" >> {{ BUILD_LOG }}
    croot
    mv .repo/local_manifests/axp.xml ${REPRMANIFEST}
    echo "[GIT] fully completed!" >> {{ BUILD_LOG }}
  args:
    executable: /bin/bash
    chdir: "{{ SRCPATH }}"
    
